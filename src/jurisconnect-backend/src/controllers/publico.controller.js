const { Demanda, Documento } = require('../models');
const { executeWithRetry } = require('../utils/dbHelpers');
const AppError = require('../utils/AppError');
const logger = require('../utils/logger');
const { randomUUID } = require('crypto');

class PublicoController {
    async obterPorToken(req, res) {
        const { token } = req.params;

        if (!token) {
            return res.status(400).json({ success: false, message: 'Token n達o fornecido' });
        }

        try {
            const demanda = await Demanda.findOne({
                where: { access_token: token },
                attributes: [
                    'id', 'numero', 'titulo', 'descricao', 'tipo_demanda',
                    'status', 'data_agendamento', 'cidade', 'estado',
                    'valor_custo', 'created_at'
                ],
                include: [
                    {
                        association: 'documentos',
                        attributes: ['id', 'nome', 'tipo', 'url', 'created_at', 'criado_por']
                    }
                ]
            });

            if (!demanda) {
                return res.status(404).json({ success: false, message: 'Demanda n達o encontrada' });
            }

            // Check if finalized
            if (['concluida', 'cancelada'].includes(demanda.status)) {
                return res.json({
                    success: true,
                    data: {
                        id: demanda.id,
                        numero: demanda.numero,
                        status: demanda.status,
                        is_finalized: true,
                        message: 'Esta demanda foi finalizada e o acesso externo foi encerrado.'
                    }
                });
            }

            res.json({
                success: true,
                data: {
                    ...demanda.toJSON(),
                    is_finalized: false
                }
            });

        } catch (error) {
            logger.logError(error);
            res.status(500).json({ success: false, message: 'Erro ao buscar demanda' });
        }
    }

    async uploadArquivo(req, res) {
        const { token } = req.params;

        if (!req.file) {
            return res.status(400).json({ success: false, message: 'Nenhum arquivo enviado' });
        }

        try {
            const demanda = await Demanda.findOne({ where: { access_token: token } });

            if (!demanda) {
                return res.status(404).json({ success: false, message: 'Demanda n達o encontrada' });
            }

            if (['concluida', 'cancelada'].includes(demanda.status)) {
                return res.status(403).json({ success: false, message: 'Demanda finalizada. Upload n達o permitido.' });
            }

            // Save document record
            // Assuming file upload middleware (multer) puts file info in req.file
            // and we have a service or logic to handle storage. 
            // For now, we'll assume a local or S3 URL is generated by middleware or we construct it.
            // Simplified for this context:

            const documento = await Documento.create({
                demanda_id: demanda.id,
                nome: req.file.originalname,
                tipo: req.file.mimetype,
                url: `/uploads/${req.file.filename}`, // Relative URL for static serving
                tamanho: req.file.size,
                publico: true
            });

            res.status(201).json({
                success: true,
                message: 'Arquivo enviado com sucesso',
                data: documento
            });

        } catch (error) {
            logger.logError(error);
            res.status(500).json({ success: false, message: 'Erro ao enviar arquivo' });
        }
    }
}

module.exports = new PublicoController();
